<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <title>JST Documentation</title>
    <link rel='stylesheet' type='text/css' href='jst.css'/>
</head>
<body>
    <p>
        JavasScript Templates (JST) is a templating technology for Java applications
        based on Javascript.  It's very similiar to Velocity or Freemarker, but it provides
        more powerful re-use, reusable layouts, utility methods, no new syntax rules, security,
        transparent escaping for HTML/XML, and many more advantages over other template
        solutions for Java.
    </p>

    <h2>Philosophy</h2>
    <p>
        All technology has a philosphy behind it.  Somehow the author is
        saying at one level or another "This is how I would solve this problem, and here
        is what matters and this other stuff doesn't."  All technology is an embodiment of
        philosophy, and so we generally choose technology based on their philosophies.
        I wrote this library mainly after constant frustration with JSP and worse JSP tags.
        I've never bought the argument for banishing Java code from JSP.  It was never an
        issue of the use of Java, but an issue of moderation.  JSP was in need of
        help, but it was really about being able to decompose portion of a page into
        reusable pieces that you could pass parameters between.  Just like a method or function
        in your programming language.  JSP was too isolated from the controller and model, and
        this produced the environment that lead to people putting too much Java code in their
        view because they didn't have any other choice.
    </p>
    <p>
        Almost every other web technology utilizes a fully turing complete language (PHP,
        eRuby, ASP) as their template language, and they don't seem to have any the problems
        JSP Tags were supposed to solve.  But, even if JSP tags were on the right track it
        created a huge canyon between view code and Java code.  Making it very difficult
        to create small utility methods for the view.  Not to mention different syntax,
        rules which as web developers we have plenty to learn (CSS, HTML, Javascript,
        Actionscript, XML, etc).
    </p>

    <p>
        Furthermore, JSP is targeted at delivery over HTTP only.  Say you want to generate
        XML, an email, etc.  JSP won't work unless you serving that output over HTTP.  There
        are many other opportunities where templating is needed.
    </p>


    <h2>Out Of the Box with HTML</h2>

    <p>
        Most people will be using JST as a replacement for JSP, velocity, or freemarker in
        their web tier so for the first part I want to show you how to use this out of the
        box for generating HTML responses over HTTP.  Later I'll show you how JST can be
        integrated as a library to anything.  Enough talk let's get started.
    </p>

    <h3>Installing the Servlet Filter</h3>

    <p>
        Adding JST to your web application only requires registering the JST servlet filter.
        Here is an example of how you'd do that:
    </p>

    <blockquote class="java">
        &lt;filter&gt;
            &lt;filter-name&gt;jst&lt;/filter-name&gt;
            &lt;filter-class&gt;jst.http.JavascriptFilter&lt;/filter-class&gt;
        &lt;/filter&gt;

        &lt;filter-mapping&gt;
            &lt;filter-name&gt;jst&lt;/filter-name&gt;
            &lt;url-pattern&gt;*.jst&lt;/url-pattern&gt;
            &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;
            &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;
        &lt;/filter-mapping&gt;
    </blockquote>

    <p>
        The first portion adds the JavascriptFilter class to your web application,
        and the mapping sends all requests dispatched as includes or forwards to
        anything ending in *.jst to this filter.  Using the jst file suffix is
        important when you are writing your jst templates.
    </p>

    <h3>Writing your first template</h3>

    <p>
        Let's make a template so create a hello.jst file in your web application.
        Add the following to hello.jst:
    </p>

    <blockquote class="java">
        Hello JST world!  It's me &lt;%= request.getParameter("name") %&gt;.
    </blockquote>

    <p>
        So pretty simple right? This demonstrates a couple of things about
        JST.  So try hitting <a href="http://localhost:8080/hello.jst?name=chuck">this
        url</a> to see the template execute.  Provided your template is at the root
        of web server it should work.  And at a high level it would print out
        the following.
    </p>

    <blockquote class="java">
        Hello JST world!  It's me chuck.
    </blockquote>

    <p>
        First is the &lt;%= %&gt; tags.  These tags are called scriptlets.  Scriptlets
        designates code that will be evaluated when this template runs.  The
        &lt;%= request.getParameter("name") %&gt; takes the output from the expression
        and puts it into HTML.  In this case it's take the value of the request parameter
        called name, and putting it into the HTML.
    </p>

    <p>
        The second thing this demonstrates is how easily the Javascript code can
        call and use Java objects.  The request object is HttpServletRequest that you have
        access to in your serlvet.  Objects request and response are automatically
        defined for all tempaltes and allow access to HttpServletRequest and
        HttpServletResponse respectively.  You can see calling methods on Java
        objects is effortless, and looks remarkably like invoking any other method
        in Javascript.  There are some differences between Javascript and Java that you
        must understand, but for right now they are not that important.
   </p>

    <h3>More on Scripting</h3>

    <p>
        Let's do something more interesting.  Let's explore more of JST.  Here is
        our next script:
    </p>

    <blockquote class="java">
        &lt;% var names = [ "chuck", "chaz", "chuckles", "chucky", "bill", "jim" ]; %&gt;

        Names that start with "CH":

        &lt;% var results = names.filter( function( item ) { return item.indexOf("ch") == 0; } -%&gt;
        &lt;ul&gt;
        &lt;% results.forEach( function( item ) { -%&gt;
            &lt;li&gt;&lt;%= item %&gt;&lt;/li&gt;
        &lt;% } -%&gt;
        &lt;/ul&gt;
    </blockquote>

    <p>
        Ok so we have jumped to light speed now.  We are processing several new things at
        once, but I am sure you can handle it.  The first line defines an array of names.
        Notice that this scriptlet tag is missing the equal sign.  That's because the
        code inside is a complete statement.  See scriptlets come in two varieties
        expressions, and statements.  Expressions evaluate to a value and that value is
        written to the HTML.  In other words expression are something that the user will
        produce results the user will see.  Statements are invisible, and don't directly
        produce output in the HTML.  They do more work or the behind the scenes heavy
        lifting.
    </p>

    <p>
        The next couple of lines produce static output.  So let's jump on down to the
        next scriptlet tag.  What's going on here?  At a high level we're writing out
        all the names that start with the letters "ch".  How does it do this?  The first
        method call filter() iterates over the names array and calls the anonymous
        function on each element of the array.  If that function returns true then that
        element will be returned in the results array.  The next scriptlet uses the forEach()
        function to iterate over the results array and calls another anonymous function for
        each element in the array.  Notice how this anonymous function mixes code
        and scriptlets.  In this case we're taking each member of the array and surrounding
        it with &lt;li&gt; tags.
    </p>

    <p>
        Lastly, notice that some of the statement scriptlets end with -%&gt; rather than
        %&gt;.  Scriptlet tags ending in -%&gt; will erase any whitespace after them.  This
        allows the statement scriptlet to really be invisible in the otuput.  Removing
        unneccessary new lines, this is very helpful when using JST outside of HTML say
        to create plain text emails.
    </p>

    <p>
        Now this template doesn't actually do anyting useful, but interesting is the methods
        we're using.  The methods filter() and forEach() are apart of Javascript 1.6
        which most browsers do not yet support.  So while you can't use those on the client
        JST can take advantage of new changes to the language when they are ready.  You
        don't have to worry about market pentration.
    </p>

    <h3>Real World JST</h3>

    <p>
        Up till now you might want to call me a liar.  What we've discussed is roughly the
        exact same thing you get with JSP.  This doesn't hold any new advantages over JSP.
        Typically, you would want to use a servlet or a controller to process requests
        coming in then forward the results to a JST template to produce the results.  Let's
        write a quick servlet that forwards to our JST template to render the view.
    </p>

    <blockquote class="java">
public class TestJSTServlet extends HttpServlet {

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        new TemplateDispatcher( request, response ).forward("hello.jst");
    }
}
    </blockquote>

    <p>
        This simply forwards the servlet's output to a javascript template named: hello.jst.
        The TemplateDispatcher is the main class used to interact between outside Servlet
        and a template.  Let's see some more compelling examples.
    </p>

    <h3>Adding Layouts</h3>

    <blockquote class="java">
public class TestJSTServlet extends HttpServlet {

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        Date today = new Date();

        new TemplateDispatcher( request, response )
            .exposeVariable( "time", today )
            .forward("timeOfDay.jst");
    }
}
    </blockquote>

    <p>
        So this is something that's very difficult to do with JSP.  Here we are sharing data
        created in our servlet with our JST template.  What the exposeVariable() method does
        is binds an object (the second parameter) as a named variable in the template
        (first parameter).  You can expose as many variables as you wish by calling that
        method multiple times.  This allows you to seperate your business logic from your
        view logic.  Let's go further.
    </p>

    <blockquote class="java">
public class TestJSTServlet extends HttpServlet {

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        Date today = new Date();

        new TemplateDispatcher( request, response )
            .exposeVariable( "time", today )
            .layout("two_column.jst")
            .forward("timeOfDay.jst");
    }
}
    </blockquote>

    <p>
        Now we've added a layout to our timeOfDay.jst template.  In this case the two_column.jst
        is combined with the results from timeOfDay.jst to render the entire HTML returned.
        The layout allows to you put common portions of your HTML page into a single reusable
        file that can be applied to many different files.  This radically simplifies creating
        a common layout.  Something that JSP makes very hard.  Let's look at the JST associated
        with both of these.  Let's look at the two_column.jst first.
    </p>

    <blockquote class="jst">
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/2000/REC-xhtml1-20000126/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;head&gt;
    &lt;meta http-equiv="content-type" content="text/html; charset=iso-8859-1" /&gt;
    &lt;style&gt;
        html {
          padding:0px;
          margin:0px;
        }
        .menu {
          float: left;
          width: 20%;
          background-color: #ff99CC;
          overflow: auto;
          padding: 1em;
        }

        .rightContent {
          float: left;
          width: 70%;
          background-color: #fff;
          margin:0px 0px 50px 0px;
          overflow: auto;
          padding: 2em;
        }
    &lt;/style&lt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;div class="menu"&gt;
            <span class="highlight">&lt;% this.leftMenu() %&gt;</span>
        &lt;/div&gt;

        &lt;div class="rightContent"&gt;
            <span class="highlight">&lt;% this.mainContent() %&gt;</span>
        &lt;/div&gt;

    &lt;/body&gt;
&lt;/html&gt;
    </blockquote>

    <p>
        Here is a very simple example of a two column layout where the left and right hand sides are
        defined in other files.  The place holders for those portions are the two function calls in the
        scriptlet tags.  Now let's see how timeOfDay.jst defines the content of each of these.
    </p>

    <blockquote class="jst">
<span class="highlight">&lt;% this.collectContentFor("leftMenu", function() { %&gt;</span>
    &lt;p&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href="/home"&gt;Home&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href="/contact"&gt;Contact Us&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href="/gallery"&gt;Gallery&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/p&gt;
&lt;% } ); %&gt;

<span class="highlight">&lt;% this.collectContentFor("mainContent", function() { %&gt;</span>
    &lt;p&gt;The time is &lt;%= today %&gt;&lt;/p&gt;
&lt;% } ); %&gt;
    </blockquote>

    <p>
        Now this shows how to define sections of content that can be added to the layout defined.  In
        the example above a call to collectContentFor() methods allows you to create a function that
        renders the given content.  The first parameter you'll notice is the name for that function,
        the second parameter is the function definition.  Here you'll see we created two functions.
        One called leftMenu and the other called mainContent.  You'll also see those function names
        used in the layout we saw above.
    </p>

    <h3>Rendering Partial Templates</h3>

    <p>
        One thing that's very important is the ability to create parts of templates that can be reused
        in lots of different files.
    </p>

    <blockquote class="jst">
&lt;%= this.render( "partial", { foo: "SomeMethod", bar: 3, baz: 34 } ) %&gt;
    </blockquote>

    The template above puts the output from the template named "partial" into that template's output.  It acts
    very much like a function call that returns a String.  In this case "partial" template is given three
    parameters named foo, bar, and baz.  These are exposed as variables the partial template can access
    directly.  This allows for parameterized output of your partial templates.

    <h3>Includes</h3>

    <p>
        Includes are another method for seperating code into reusable files.  This makes reusing code
        very easy.  Lots of frameworks make it difficult to create view utility methods.  While you
        can seperate business logic you still need lots of methods specifically for handling view logic.
    </p>

    <blockquote class="jst">
&lt;% this.include("html.js"); %&gt;

&lt;%= Html.link( "/calculate", "Click Here" ) %&gt;
    </blockquote>

    <p>
        Here is an example of a jst template that includes the html script file.  In this example, we're
        including one of the scripts shipped with JST.  Here we're creating a href in our HTML.  You can
        include any script you want.  You can create your own javascript files and include them using
        the include method on the template object.  The path to your script is relative to your template
        you are executing.
    </p>

    <p>
        Here's another example creating your own javascript function.
    </p>

    <blockquote class="jst">
&lt;% this.include( "helper.js" ); %&gt;
&lt;html&gt;
&lt;body&gt;
      &lt;h1&gt;&lt;%= Helper.doSomethingHelpful("Georgia Tech") %&gt;&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
    </blockquote>

    <p>
        In this example we're including the helper.js file, and calling a function included within it.  Here
        is the code for helper.js
    </p>

    <blockquote class="jst">
var Helper = {
    doSomethingHelpful: function ( team ) {
        return "{0} wins the national championship!".format( team );
    }
};
    </blockquote>

    <p>
        Here you can see helper is using the String.format() method defined by the jst.js file which
        is automatically included in every template.
    </p>

    <h3>Mixins</h3>

    <p>
        Mixins are a unique way of adding methods directly into your templates.  You can mixin
        Java objects directly into your template.  This is handy to create helper functions for all
        of your templates, and integrate directly with Java.  Here is an example:
    </p>

    <blockquote class="java">
public class TestJSTServlet extends HttpServlet {

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        Date today = new Date();

        new TemplateDispatcher( request, response )
            .exposeVariable( "time", today )
            .mixin( "timeUtility", new TimeUtility( today ) )
            .forward("timeOfDay.jst");
    }
}
    </blockquote>

    <p>
        In this example we've added a mixin called TimeUtility.  The methods on TimeUtility will be
        exposed to our template as plain old methods on it.  The first parameter is a unique name
        given to our mixin.  The user doesn't really use this to access the mixin methods.
    </p>

    <h3>Using JST outside of the Web</h3>

    <p>Todo</p>

</body>
</html>